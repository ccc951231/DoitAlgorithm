package chap2;


//1000이하의 소수를 열거(버전2)
public class PrimeNumber2 {

	public static void main(String[] args) {
		
		int counter = 0;  
		int ptr = 0;
		int[] prime = new int[500];
		
		// prime[2, 3, 5, 11]
		prime[ptr++] = 2; // 1-1prime[0]번째 값은2이고, prime[1]로 넘어간다. 
		
		for(int n=3; n <= 1000; n += 2) {  // 1-2. n=3   2-1. n=3+2 증감 후 n=5  3-1. n=5+2 증감 후 n=7  4-1. n=9  5-1. n=11
			int i;  
			
			// for문의 ptr은 배열의 길이를 의미
			for(i=1; i<ptr; i++) {  // 1-3. i<ptr = 1<1 성립x -> if문으로 빠져나감. 2-2. 1<2 성립o  2-4. 2<2 성립x   립o  2-3. 2<5  2-5. 3<5  2-6. 4<5 2-7. 5<5 성립x -> 종료
								 	// 3-2. 1<3 성립o 3-4. 2<3 성립o  3-6. 3<3 성립x -> 종료후 if문으로 빠져나감.  4-2. 1<4  4-4. 2<4  5-2. 1<4  5-4. 2<4  5-6.3<4  5-8. 4<4 성립x ->반복문 종료 if문으로..
				counter++; // 1증가
				
				// if문의 prime[i]는 배열 내부의 값을 의미, 배열 내부의 값을 차례대로 대입하여 n을 나눔
				if(n % prime[i] == 0) // 2-3. 5/2(배열1번째 값)나머지1, 5/3(배열1번째 값)나머지2     2-4. 5/3(배열1번째 값) 나머지2 2-6. 5/3(배열1번째 값) 나머지2 2-7. 5/3(배열1번째 값) 나머지2 
					break;			  // 3-3. 7/2 나머지1  3-5. 7/3 나머지1  4-3. 9/2 나머지1  4-5. 9/3 나머지0 -> for문 종료  5-3. 11/2..1  5-5. 11/3..2  5-7. 11/5..1
				
			}
			if(ptr == i) // 1-4. 1=1 true  2-5. 2=2 true  3-7. 3=3  4-6. 4=2 false 5-9. 4=4 true
				prime[ptr++] = n; // 1-5. n=3 -> 배열 번지 증감 prime[1] = n -> prime[1]에 저장된 값은 3  2-6. n=5 -> 배열 번지 증감 prime[2] = n -> prime[2]에 저장된 값은 5
		}						 // 3-8.  n=7 -> 배열 번지 증감 prime[3] = n -> prime[3]에 저장된 값은 7  5-10. prime[4] = 11
		
		for(int i=0; i < ptr; i++)  // 배열길이인 ptr=4 / i=0~3돌기 4번 반복 i가 4가되면 종료
			System.out.println(prime[i]); // 0번째 = 2출력, 1번째=3출력, 2번째=5출력, 3번째=7출력 4번째=11출력
		
		System.out.println("나눗셈을 수행한 횟수 : " + counter);

	}

}
